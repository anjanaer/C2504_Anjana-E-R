Solution Overview
Maintain a Dictionary for Filters:
Use a Dictionary<string, List<FilterItem>> where the key is the column name, and the value is the list of FilterItem objects for that column.

Bind FilterValues Dynamically:
Update the FilterValues property dynamically based on the selected column.

Preserve Filters:
When switching columns, save the current state of FilterValues back to the dictionary.

Implementation
1. Add a Dictionary for Column Filters
Add a dictionary in your MainViewModel to store filter values for each column:

csharp
Copy code
private Dictionary<string, List<FilterItem>> columnFilters = new Dictionary<string, List<FilterItem>>();

public Dictionary<string, List<FilterItem>> ColumnFilters
{
    get => columnFilters;
    set
    {
        columnFilters = value;
        OnPropertyChanged(nameof(ColumnFilters));
    }
}
2. Update FilterValues Dynamically
Modify the FilterValues property to reflect the filters for the selected column:

csharp
Copy code
private List<FilterItem> filterValues;

public List<FilterItem> FilterValues
{
    get => filterValues;
    set
    {
        filterValues = value;
        OnPropertyChanged(nameof(FilterValues));
    }
}

private string selectedColumnFilter;

public string SelectedColumnFilter
{
    get => selectedColumnFilter;
    set
    {
        if (selectedColumnFilter != value)
        {
            // Save the current filter values before switching columns
            if (!string.IsNullOrEmpty(selectedColumnFilter))
            {
                ColumnFilters[selectedColumnFilter] = new List<FilterItem>(FilterValues);
            }

            selectedColumnFilter = value;

            // Load the filter values for the newly selected column
            if (ColumnFilters.ContainsKey(selectedColumnFilter))
            {
                FilterValues = new List<FilterItem>(ColumnFilters[selectedColumnFilter]);
            }
            else
            {
                FilterValues = new List<FilterItem>(); // Initialize if no filter exists
            }

            OnPropertyChanged(nameof(SelectedColumnFilter));
        }
    }
}
3. Apply Filter Logic
Update your ApplyFilter method to use ColumnFilters:

csharp
Copy code
private void ApplyFilter()
{
    if (!ColumnFilters.Any()) return;

    FilteredData = new ObservableCollection<ExcelData>(
        Data.Where(dataItem =>
        {
            foreach (var columnFilter in ColumnFilters)
            {
                var propertyValue = dataItem.GetType().GetProperty(columnFilter.Key)?.GetValue(dataItem)?.ToString();
                if (columnFilter.Value.Any(f => f.IsSelected) && 
                    !columnFilter.Value.Any(f => f.IsSelected && f.Value == propertyValue))
                {
                    return false;
                }
            }
            return true;
        })
    );

    IsFilterApplied = ColumnFilters.Values.Any(f => f.Any(item => item.IsSelected));
}
4. Reset Specific Column Filter
To reset filters for the currently selected column:

csharp
Copy code
private void ResetColumnFilter()
{
    if (!string.IsNullOrEmpty(SelectedColumnFilter))
    {
        if (ColumnFilters.ContainsKey(SelectedColumnFilter))
        {
            ColumnFilters[SelectedColumnFilter].Clear();
            FilterValues.Clear();
        }
    }

    ApplyFilter();
}
5. Initialize ColumnFilters
Ensure ColumnFilters is initialized for all available columns:

csharp
Copy code
foreach (var columnName in Data.FirstOrDefault()?.GetType().GetProperties().Select(p => p.Name) ?? new List<string>())
{
    ColumnFilters[columnName] = new List<FilterItem>();
}
How It Works
Switching Columns:

When switching columns (SelectedColumnFilter), save the current filter values into the ColumnFilters dictionary.
Load the saved filter values for the newly selected column into FilterValues.
Applying Filters:

The ApplyFilter method processes all filters stored in the ColumnFilters dictionary, ensuring filters for all columns are applied simultaneously.
Resetting Filters:

Use ResetColumnFilter to clear the filters for a specific column or reset all filters by clearing the ColumnFilters dictionary.
This approach ensures that:

Filters for each column are saved independently.
Switching columns does not affect the previously applied filters for other columns.
The UI reflects the saved state of filters for the currently selected column.





You said:
foreach (var columnName in Data.FirstOrDefault()?.GetType().GetProperties().Select(p => p.Name) ?? new List<string>())
{
    ColumnFilters[columnName] = new List<FilterItem>();
}Where does it initializw
ChatGPT said:
ChatGPT
The code snippet you provided initializes the ColumnFilters dictionary by adding an entry for each column in your data source. This initialization should be done when your data (Data collection) is first loaded or whenever it changes (e.g., after fetching the data from a file or database).

Here’s where and how you can initialize it:

Initialization Location
You can place the initialization logic in the following scenarios:

In the ViewModel Constructor:
If your data is already available when the ViewModel is created.

After Data is Loaded:
If your data is being loaded asynchronously or at runtime.

Example 1: Initialization in the Constructor
csharp
Copy code
public MainViewModel()
{
    // Assuming Data is already initialized
    InitializeColumnFilters();
}
Example 2: Initialization After Data Load
csharp
Copy code
private ObservableCollection<ExcelData> data;
public ObservableCollection<ExcelData> Data
{
    get => data;
    set
    {
        data = value;
        OnPropertyChanged(nameof(Data));
        InitializeColumnFilters(); // Reinitialize filters whenever data changes
    }
}
InitializeColumnFilters Method
Here’s how you can define the InitializeColumnFilters method:

csharp
Copy code
private void InitializeColumnFilters()
{
    ColumnFilters.Clear(); // Clear any existing filters

    if (Data?.Any() == true)
    {
        // Create an empty list of filters for each column
        foreach (var columnName in Data.FirstOrDefault()?.GetType().GetProperties().Select(p => p.Name) ?? new List<string>())
        {
            if (!ColumnFilters.ContainsKey(columnName))
            {
                ColumnFilters[columnName] = new List<FilterItem>();
            }
        }
    }
}
Example Workflow
Data is Loaded:
The Data collection is populated, either at initialization or after being fetched.

ColumnFilters Initialization:

InitializeColumnFilters iterates through the properties of the Data objects.
Each property name is treated as a column name, and an empty filter list is assigned to it.
Filters Are Ready:
You can now add FilterItem objects to the lists in ColumnFilters for each column.

Why Initialize Here?
It ensures that ColumnFilters always matches the structure of your Data collection.
If your Data changes dynamically (e.g., file import), ColumnFilters is reinitialized accordingly.
This setup maintains flexibility and synchronization between your data and filters.











